import time

loading_start = time.time()
import argparse
import numpy as np
from PIL import Image
from keras.models import load_model
from keras.optimizers import SGD
from models.googlenet_custom_layers import PoolHelper, LRN

from transformation import *

ageAndGenderModel = None  # global variable that holds the loaded model

loading_end = time.time()
# print('Loading of Python Script took ' + str(loading_end-loading_start) + ' seconds')

def load_image(image_path):
  # print("Loading image ...")
  try:
    with Image.open(image_path) as img:
      img_data = np.asarray(img)
      # print(" Shape: %s" % str(img_data.shape))
  except FileNotFoundError as e:
    print('Failed loading image %s' % image_path)
    exit()
  return img_data


def load_classifier(model_path):
  try:
    model = load_model(model_path, custom_objects={'LRN':LRN})
    # print(" Input shape: %s, %i classes" % (
    #   str(model.layers[0].batch_input_shape[1:]), model.layers[-1].output_dim))
    learning_rate = 1e-2
    opt = SGD(lr=learning_rate, momentum=0.9, nesterov=True)
    model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['accuracy'])
    global ageAndGenderModel
    ageAndGenderModel = model
  except OSError as e:
    print('Failed loading model %s' % model_path)
    print(e)
    exit()


def set_classifier(model):
  global ageAndGenderModel
  ageAndGenderModel = model


def preprocess_image(sample, means=None, stds=None, dims=None, out_shape=None):
  # print("Preprocessing image ...")
  # print(" Transformations in order:")
  tform = TransformationSequence()

  if dims is not None:
    t = ResizeTransformation(dims)
    tform.add_transformation(t)
    # print("  %s" % t.__class__.__name__)

  t = FloatCastTransformation()
  tform.add_transformation(t)
  # print("  %s" % t.__class__.__name__)

  if means is not None:
    t = PerChannelSubtractionImageTransformation(np.array(means, dtype=np.float32))
    tform.add_transformation(t)
    # print("  %s (%s)" % (t.__class__.__name__, str(t.values())))

  if stds is not None:
    t = PerChannelDivisionImageTransformation(np.array(stds, dtype=np.float32))
    tform.add_transformation(t)
    # print("  %s (%s)" % (t.__class__.__name__, str(t.values())))

  if out_shape is not None:
    t = ReshapeTransformation(out_shape)
    tform.add_transformation(t)
    # print("  %s %s" % (t.__class__.__name__, str(t.value())))

  sample = tform.apply(sample)
  # print(" Result: shape: %s, dtype: %s, mean: %.3f, std: %.3f" % (
  #   sample.shape, sample.dtype, sample.mean(), sample.std()))

  return sample


# ['female', 'male']
# [
#       '[0 - 15]', '[16 - 20]', '[21 - 25]', '[26 - 30]', '[31 - 35]',
#       '[36 - 40]', '[41 - 45]', '[46 - 50]', '[51 - 55]', '[56 - 100]'
#     ]
def classify_image(image, model=None, means=[0.45008409, 0.37675238, 0.3356632], stds=[0.28836954, 0.26367465, 0.2598381]):
  """
  Classify an image with the age and gender classifier. Before calling this method, please set the model with
  load_classifier() or set_classifier() or you specifiy a model to this method by setting the model parameter.
  :param image: An image in a typical numpy standard format. We tested it for example with images generated by:
  with Image.open(image_path) as img:
      img = np.asarray(img)
  :param model: Optional if already set. If you want to use another model than set by load_classifier() or
  set_classifier() you can use this parameter. Otherwise please use the two mentioned functions before to set the model
  once.
  :param means: Optional. The mean which is subtracted from the images. Default values were computed from the IMDB-Wiki
  dataset
  :param stds: Optional. The standard deviation which is used to normalize the image. Default values were computed
  from the IMDB-Wiki dataset
  :return: a list with 4 values: [gender_class_id, age_class_id, gender_class_confidence, age_class_confidence].
  The gender_class_id is 0 or 1 and represents an index for the following classes:
  ['female', 'male']
  The age_class_id is an index of the following array of age classes:
  ['[0 - 15]', '[16 - 20]', '[21 - 25]', '[26 - 30]', '[31 - 35]',
   '[36 - 40]', '[41 - 45]', '[46 - 50]', '[51 - 55]', '[56 - 100]']
  """
  if model is None:
    if ageAndGenderModel is None:
      print('ERROR: Please load an age and gender model before trying to classify an image with it...')
      exit()
    model = ageAndGenderModel  # take the standard model because nothing is passed

  sample = preprocess_image(image, means=means, stds=stds, dims=(112, 112, 3), out_shape=(3, 112, 112))

  # Expand the sample (3,112,112) to batch dimension (1,3,112,112)
  X = np.expand_dims(sample, axis=0)

  #probas = model.predict_proba(X, batch_size=1, verbose=0).reshape(-1)
  predictions = model.predict(X, batch_size=1, verbose=0)
  #predictions_classes = model.predict_classes(X, batch_size=1, verbose=0)


  # Get the class index of the highest probability
  gender_class_id = np.argmax(predictions[1][0])
  gender_class_confidence = predictions[1][0][gender_class_id]
  age_class_id = np.argmax(predictions[0][0])
  age_class_confidence = predictions[0][0][age_class_id]

  return [gender_class_id, age_class_id, gender_class_confidence, age_class_confidence]



def demo_classification():
  """
  Performs a demo classification.
  Example output on a relatively slow machine with no GPU support:
  Starting Demo Classification...
  Loading of the model took 12.141696214675903 seconds
  The person on the image is male and [21 - 25] years old
  Classification took 0.45056692361831663 seconds per image
  """

  print('Starting Demo Classification...')

  # 1. Load model
  start = time.time()
  model = load_classifier('ageGenderModel.h5')
  end = time.time()
  print('Loading of the model took ' + str(end-start) + ' seconds')

  # 2. Load Images (or get them somewhere)
  image = load_image('../data/obama112.png')

  # 3. Classify Images
  start = time.time()
  dict_gender = ['female', 'male']
  dict_age = [
      '[0 - 15]', '[16 - 20]', '[21 - 25]', '[26 - 30]', '[31 - 35]',
      '[36 - 40]', '[41 - 45]', '[46 - 50]', '[51 - 55]', '[56 - 100]'
    ]
  iterations = 20  # Try several times to see how long it really takes
  for i in range(0, iterations):
    classification_results = classify_image(image)
    gender_class_id = classification_results[0]
    age_class_id = classification_results[1]
    gender_class_confidence = classification_results[2]
    age_class_confidence = classification_results[3]
  end = time.time()
  # Take last result as an example and print it:
  print('The person on the image is ' + dict_gender[gender_class_id] + ' and ' + dict_age[age_class_id] + ' years old')

  # Note that if you want to classify more images, Keras offers also batch classification
  print('Classification took ' + str((end-start)/iterations) + ' seconds per image')


# ['female', 'male']
# [
#       '[0 - 15]', '[16 - 20]', '[21 - 25]', '[26 - 30]', '[31 - 35]',
#       '[36 - 40]', '[41 - 45]', '[46 - 50]', '[51 - 55]', '[56 - 100]'
#     ]
# def main():
#   parser = argparse.ArgumentParser()
#   parser.add_argument('--model', dest='model',
#     help='Path to the model', default='model_best.h5')
#   parser.add_argument('--image', dest='image',
#     help='Path to the RGB input image')
#   parser.add_argument('--means', dest='means', type=float, nargs='+',
#     help='Mean subtraction for preprocessing')
#   parser.add_argument('--stds', dest='stds', type=float, nargs='+',
#     help='Stddev division for preprocessing')
#
#   print("Parsing arguments ...")
#   args = parser.parse_args()
#
#   print(" Model: %s" % args.model)
#   print(" Image: %s" % args.image)
#   print(" Means: %s" % str(args.means))
#   print(" Stds: %s" % str(args.stds))
#
#   perform_classification(args.model, args.image, args.means, args.stds)
#
# if __name__ == '__main__':
#   main()